// Code generated by go generate; DO NOT EDIT.
package pkg

import (
	"errors"
	"flag"
	"fmt"
	"os"
	"strings"
	"time"
)

// Config represents all configuration options.
type Config struct {
	// Node ID
	NodeID string
	// HTTP API bind address
	HTTPAddr string
	// An interval of time
	Interval time.Duration
	// A slice of strings
	List []string
	// Another slice of strings with a default and explicit delimiter
	List2 []string
	// path to config file
	ConfigFile string `filepath:"true"`
}

// Forge sets up and parses command-line flags.
func Forge(arguments []string) (*flag.FlagSet, *Config, error) {
	config := &Config{}
	fs := flag.NewFlagSet("name", flag.ExitOnError)
	fs.StringVar(&config.NodeID, "-node-id", "", "Node ID")
	fs.StringVar(&config.HTTPAddr, "-http-addr", "localhost:4001", "HTTP API bind address")
	fs.DurationVar(&config.Interval, "-interval", mustParseDuration("10s"), "An interval of time")
	var tmpList string
	fs.StringVar(&tmpList, "-list", "", "A slice of strings")
	var tmpList2 string
	fs.StringVar(&tmpList2, "-list2", "foo", "Another slice of strings with a default and explicit delimiter")
	fs.StringVar(&config.ConfigFile, "-config-file", "", "path to config file")
	if err := fs.Parse(arguments); err != nil {
		return nil, nil, err
	}
	config.List = splitString(tmpList, ",")
	config.List2 = splitString(tmpList2, "#")
	return fs, config, nil
}

func mustParseDuration(d string) time.Duration {
	td, err := time.ParseDuration(d)
	if err != nil {
		panic(err)
	}
	return td
}

func splitString(s, sep string) []string {
	if s == "" {
		return nil
	}
	return strings.Split(s, sep)
}

func fmtError(msg string) error {
	return errors.New(msg)
}

func usage(msg string) {
	fmt.Fprintf(os.Stderr, "%s", msg)
}
